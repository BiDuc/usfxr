usfxr
=====

usfxr is a C# library used to generate game-like procedural audio effects inside Unity. With usfxr, one can easily synthesize sound in real time for actions such as item pickups, jumps, lasers, hits, explosions, and more.

usfxr is a port of Thomas Vian's [as3sfxr](https://code.google.com/p/as3sfxr/), which itself is an ActionScript 3 port of Tomas Pettersson's [sfxr](http://www.drpetter.se/project_sfxr.html).

[This video](https://vimeo.com/15769163) explains the ideas behind as3sfxr, and the ideas that I want to support with usfxr.

Despite my name not being Thomas or a variant of it, I found myself wishing for a (free) library to procedurally generate audio inside Unity in real time, and usfxr is the result.


Introduction
------------

First things first: if you're just looking for a few good 16 bit-style sound effects to use in games, anyone can use sound files generated by [the original sfxr](http://www.drpetter.se/project_sfxr.html) or [as3sfxr's online version](http://www.superflashbros.net/as3sfxr/) without any changes, since both applications generate ready-to-be-used audio files.

However, by using a runtime library like usfxr, you can generate the same audio samples in real time, or re-synthesize effects generated in any of those tools by using a small list of parameters (a short string). The advantages of this approach are twofold:

* Audio is generated in real time; there's no storage of audio files as assets necessary, making compiled project sizes smaller
* Easily play variations of every sound you play; adds more flavor to the gameplay experience

I make no claims in regards to the source code or interface, since it was simply adapted from Thomas Vian's own code and (elegant) interface. As such, usfxr contains the same features offered by as3sfxr, such as caching of generated audio and ability to play sounds with variations. But because it is adapted to work on a different platform, however, it has advantages of its own:

* Fast audio synthesis
* Ability to cache sounds the first time they're played
* Completely asynchronous caching and playback: sound is generated on a separate, non-blocking thread with minimal impact on gameplay
* Minimal setup: as a full code-based solution, no drag-and-drop or additional game object placement is necessary


Installation
------------

Download the latest "usfxr" zip file from the "/build" folder of the GitHub repository and extract the contents of this file into the "Scripts" (or equivalent) folder of your Unity project.


Usage
-----

Typically, the workflow for using usfxr inside a project is as such:

1. Visit the [online version of as3sfxr](http://www.superflashbros.net/as3sfxr/), play around, and generate a sound effect that you want to use
2. Press CTRL+C to copy the effect script to the clipboard (as a string)
3. Back in Unity, write some code to store your sound effect, pasting the correct string

<!-- hack to allow code formatting -->

	SfxrSynth synth = new SfxrSynth();
	synth.parameters.setSettingsString("0,,0.032,0.4138,0.4365,0.834,,,,,,0.3117,0.6925,,,,,,1,,,,,0.5");

Finally, to play your audio effect, you simply do:

	synth.Play();

With usfxr, all audio data is generated the first time an effect is played. That way, any potential heavy load in generating audio doesn't have to be repeated. Because of that, while it's possible to generate new SfxrSynth instances every time they need to be played, it's usually a better idea to keep them around and reuse them as needed.

#### Advanced usage: caching

In case of long or numerous audio effects, it makes sense to cache them first, before they are allowed to be played. This is done by calling the cacheSound() method first, as in:

	SfxrSynth synth = new SfxrSynth();
	synth.parameters.SetSettingsString("0,,0.032,0.4138,0.4365,0.834,,,,,,0.3117,0.6925,,,,,,1,,,,,0.5");
	synth.CacheSound();
	...
	synth.Play();

As a reference, it typically takes around 7ms-70ms for an audio effect to be cached on a desktop computer, depending on its length and complexity. Therefore, sometimes it's better to let game cache sound as they're played, if possible (only a small portion of the audio is generated at a time), or to stack the caching of all audio in the beginning of the gameplay, such as before a level starts. Check the samples for an example of how this is done.

#### Advanced usage: setting the audio position

By default, all audio is attached to the first main `Camera` available (that is, [`Camera.main`](http://docs.unity3d.com/Documentation/ScriptReference/Camera-main.html)). If you want to attach your audio playback to a different game object - and thus produce positional audio - you use `SetParentTransform`, as in:

	synth.SetParentTransform(gameObject.transform);

This attaches the audio to an specific game object. See the documentation for more details.


Samples
-------

Other than the source code to usfxr, the Git repository contains a few example projects using the library. The intention is to provide examples of how to properly use usfxr by solving common patterns that emerge in game development when it comes down to playing audio. The currently available sample projects are as such


#### Benchmark

This is a C# project that serves as a benchmark of the audio generation code. Run this example in different platforms to get an idea of how long it takes for that system to generate each audio sample. Because the audio is generated in real time the first time it has to be played, heavy audio generation can have a negative impact on game performance, so one must keep the results of this test in mind when deciding on a procedural audio solution for a game. A performance hit in audio generation may mean that you have to generate audio caches before a level is started, or in a worst case even abandoning the idea of using procedural audio.


#### SpaceGame

(...todo...)


#### SpaceGamePreloaded

(...todo...)


Reference
---------

(...todo...)


Contribute
----------

(...todo...)


Changelog
---------

#### 2013-04-06

* Users can now set the parent transform of the audio (for proper audio positioning) with `SetParentTransform()`
* Replaced `Random.value` calls with a more correct `getRandom()` function
* Added `SfxrSynth.CacheMutations()` (fixes #12)

For a list of things that need to be done, check the [issues](https://github.com/zeh/usfxr/issues) tab.