usfxr
=====

usfxr is a C# library to generate and play audio effects in real time inside a Unity game. With usfxr, one can easily synthesize audio for typical game-related actions such as item pickups, jumps, lasers, hits, explosions, and more.

It is a Unity-compatible C# port of Thomas Vian's [as3sfxr](https://code.google.com/p/as3sfxr/), which itself is an ActionScript 3 port of Tomas Pettersson's [sfxr](http://www.drpetter.se/project_sfxr.html).

[This video](https://vimeo.com/15769163) explains the ideas behind as3sfxr much better than I can describe it here.

Despite my name not being Thomas or a variant of it, I found myself wishing for a (free) library to procedurally generate audio inside Unity in real time, and usfxr is the result.


Introduction
------------

First things first: if you're just looking for a few good 16 bit-style sound effects to use in games, anyone can use sound files generated by [the original sfxr](http://www.drpetter.se/project_sfxr.html) or [as3sfxr's online version](http://www.superflashbros.net/as3sfxr/) without any changes, since both applications generate audio files.

However, by using a runtime library like usfxr (inspired by as3sfxr), you can generate the same audio samples in real time, or re-synthesize effects generated in any of those tools by using a small list of parameters (a short string). The advantages of this approach are twofold:

* Audio is generated in real time; there's no storage of audio files as assets necessary, making compiled project sizes smaller
* Easily play variations of every sound (like jumps); adds more flavor to the gameplay experience

I make no claims in regards to the source code or interface, since it was simply adapted from Thomas Vian's own code and (elegant) interface. As such, usfxr contains the same features offered by as3sfxr, such as caching of generated audio and ability to play sounds with variations. But because it is adapted to work on a different platform, however, it has advantages of its own:

* Fast audio synthesis
* Ability to cache sounds the first time they're needed
* Completely asynchronous caching and playback; sound is generated on a separate, non-blocking thread with minimal impact on gameplay
* Minimal setup necessary; full code-based solution, no drag-and-drop or additional game objects necessary


Installation
------------

1. Download the latest "usfxr" zip file from the "/build" folder of the GitHub repository
2. Unzip this zip into the "Scripts" (or equivalent) folder of your Unity project

Your project is now ready to use usfxr.


Usage
-----

Typically, the workflow for using usfxr inside a project is as such:

1. Visit the [online version of as3sfxr](http://www.superflashbros.net/as3sfxr/), play around, and generate a sound effect that you want to use
2. Press CTRL+C to copy the effect script to the clipboard
3. Back in Unity, write some code to store your sound effect:

	SfxrSynth synth = new SfxrSynth();
	synth.parameters.setSettingsString("0,,0.032,0.4138,0.4365,0.834,,,,,,0.3117,0.6925,,,,,,1,,,,,0.5"); // Replace the string here with the code from as3sfxr

4. Finally, to play your audio effect, you simply do:

	synth.play();

With usfxr, all audio data is generated the first time an effect is played. That way, any potential heavy load in generating audio doesn't have to be repeated. Because of that, while it's possible to generate new SfxrSynth instances every time they need to be played, it's usually a better idea to keep them around and reuse them as needed.

In case of long or numerous audio effects, it makes sense to cache them first, before they are allowed to be played. This is done by calling the cacheSound() method first, as in:

	SfxrSynth synth = new SfxrSynth();
	synth.parameters.setSettingsString("0,,0.032,0.4138,0.4365,0.834,,,,,,0.3117,0.6925,,,,,,1,,,,,0.5"); // Replace the string here with the code from as3sfxr
	synth.cacheSound();
	...
	synth.play();

As a reference, it typically takes around 7ms for an audio effect to be cached on a desktop computer. Therefore, it's better to let game cache sound as they're played, if possible (only a small portion of the audio is generated at a time), or to stack the caching of all audio in the beginning of the gameplay, such as before a level starts.


Documentation
-------------



Samples
-------



-------

TODO:
* Test if SfxrParams.pow() is actually faster than using pow
* Test if SfxrParams.to4DP() is returning numbers correctly (1.00001 becomes 1.00000, etc) - maybe round it?
* Replace Random.value with a different function? The original used Math.random(), which returns 0 <= n < 1, while Random.value returns 0 <= n <= 1
* replace getTimer() on SfxrSynth with a Time specific call?
* Too many potential conversions between uint/int - move everything to int?
* Allow user to set the game object parent/position for proper control
* cacheMutations()?
* cacheSection()?
* Use AudioSettings.outputSampleRate;?
* SfxrParam: replace clamp1() and clamp2() with native clamp calls (test speed)
* Conform to the language's conventions (uppercase letter on methods...)

* Line 496 of SfxrSynth: awkward conversion (was implying from float to int): _changeLimit = (int)((1f - p.changeSpeed) * (1f - p.changeSpeed) * 20000f + 32f);
* Line 682 of SfxrSynth: awkward conversion (was implying from float to int): _phase = _phase - (int)_periodTemp;
* Line 552 of SfxrSynth: awkward conversion: _envelopeFullLength was originally a float, but used as an uint everywhere else, so I'm doing the conversion earlier. what kind of unit is this? it may be cutting the audio short
* Line 262 of SfxrSynth: test filling of data samples to see what's faster

* Re-enable other functions on SfxrSynth that have been temporarily disabled - search for [[disabled]]
* Search for (uint) casts -- too many...

* Re-enable wav file generation? turn on getWavFile(), and allow waveData false on synthWave() on SfxrSynth

* Samples:
  shooter
  +life: 1,,0.2702,,0.3426,0.2518,,0.2489,,,,,,,,0.4788,,,1,,,,,0.5
  shooting: 2,,0.1857,,0.2642,0.7423,0.2715,-0.1968,,,,,,0.1105,0.1948,,,,1,,,0.0922,,0.5
  enemy hit: 2,,0.0303,,0.2563,0.6111,,-0.4382,,,,,,0.3283,,,,,1,,,,,0.49
  explosion: 2,,0.2067,0.5678,0.3768,0.4351,,-0.2241,,,,-0.2703,0.7393,,,,,,1,,,,,0.5
             3,,0.2067,0.5678,0.3768,0.4351,,-0.2241,,,,-0.2703,0.7393,,,,,,1,,,,,0.5
  pickup: 2,,0.0355,0.3878,0.4833,0.6526,,,,,,0.3927,0.5636,,,,,,1,,,,,0.5
  explosion/die: 3,,0.3708,0.3227,0.242,0.3149,,-0.3596,,,,0.7839,0.7648,,,,0.1186,-0.1399,1,,,,,0.5
  die: 2,,0.0782,0.6203,0.9024,0.5044,,-0.1298,0.0094,-0.0008,-0.5123,0.2868,-0.3859,-0.8811,0.9692,0.3616,0.001,0.0001,0.9528,0.0437,-0.4492,0.1089,,0.5

Missing aspects:
* events/callbacks

Features:
* Use Coroutines/yield to asynchronously create the data? And then drop the time-based generation entirely?